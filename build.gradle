import java.nio.file.Paths

/*
 * A program to automatically trade cryptocurrencies.
 * Copyright (C) 2020 Tomas Skalicky
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

// Plugins along with versions are configured here, not in buildscript to avoid mixture of classpaths of plugins.
//
// The block "plugins { ... }" is located here, not in settings.gradle, in order to avoid a failure
// "Plugin with id 'io.spring.dependency-management' not found." otherwise caused by
// applying the plugin 'io.spring.dependency-management' in dependencyManagement.gradle.
//
// Be noted plugins are not automatically applied.
plugins {
    // See https://plugins.gradle.org/plugin/com.github.ben-manes.versions
    id 'com.github.ben-manes.versions' version '0.39.0' apply false

    // See https://github.com/policeman-tools/forbidden-apis
    id 'de.thetaphi.forbiddenapis' version '3.1' apply false

    // See https://plugins.gradle.org/plugin/io.spring.dependency-management
    id 'io.spring.dependency-management' version '1.0.11.RELEASE' apply false

    // See https://plugins.gradle.org/plugin/org.springframework.boot
    id 'org.springframework.boot' version '2.5.1' apply false
}

group = 'com.skalicky'
version = '0.0.1-SNAPSHOT'

if (gradle.startParameter.taskNames.contains('dependencyUpdates')) {
    apply plugin: 'com.github.ben-manes.versions'
}

allprojects {

    logging.captureStandardOutput LogLevel.WARN

    apply from: "$rootDir/libraries.gradle"

    configurations {
        all {
            // https://docs.gradle.org/current/userguide/dependency_management.html#component_selection_rules
            // https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ResolutionStrategy.html
            resolutionStrategy {
                // fail eagerly on version conflict (includes transitive dependencies)
                // e.g. multiple different versions of the same dependency (group and name are equal)
                failOnVersionConflict()

                componentSelection {
                    all { final ComponentSelection selection ->
                        final def rejected_substrings = ['alpha', 'beta', 'rc', 'M1']
                        final boolean rejected = rejected_substrings.any { final qualifier ->
                            selection.candidate.version ==~ /(?i).*[.-]${qualifier}[.\d-]*/
                        }
                        if (rejected) {
                            selection.reject("Rejected substrings $rejected_substrings")
                        }
                    }
                }
            }
        }
    }
}

subprojects {

    apply from: "$rootDir/dependencyManagement.gradle"
    // See https://docs.gradle.org/current/userguide/jacoco_plugin.html
    apply plugin: 'de.thetaphi.forbiddenapis'
    apply plugin: 'jacoco'
    apply plugin: 'java'
    apply plugin: 'java-library'

    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11

    repositories {
        mavenCentral()
    }

    forbiddenApis {
        signaturesFiles = files("$rootDir/configuration/forbidden_apis/signatures.txt")
        ignoreFailures = false
    }

    forbiddenApisTest {
        // A Configuration like "testCompileClasspath" is instantiated and configured during the configuration phase,
        // hence the code requiring a Configuration being configured needs to run at the very end of the configuration
        // phase. To put a code there, use "afterEvaluate".
        project.afterEvaluate {
            //  The forbidden APIs must be on the classpath of the gradle sub-project, hence the set of forbidden APIs
            //  need to be split by libraries and applied only when a particular library is on the classpath.
            if (isLibraryOnClasspath(configurations.testCompileClasspath, groupNames.org_mockito, artifactNames.mockito_core)) {
                signaturesFiles += files("$rootDir/configuration/forbidden_apis/mockito_signatures.txt")
            }
            if (isLibraryOnClasspath(configurations.testCompileClasspath, groupNames.org_assertj, artifactNames.assertj_core)) {
                signaturesFiles += files("$rootDir/configuration/forbidden_apis/assertj_signatures.txt")
            }
        }
    }

    test {
        useJUnitPlatform()
        finalizedBy jacocoTestReport
    }

    jacocoTestReport {
        dependsOn test
        reports {
            html.enabled true
            csv.enabled true
        }
    }

    jacoco {
        toolVersion = versions.jacoco_tool
    }

    jar {
        archiveBaseName.set(determineArchiveBaseName(project))
    }
}

tasks.named('wrapper') {
    gradleVersion versions.gradle
    distributionType = Wrapper.DistributionType.ALL
}

final String determineArchiveBaseName(final Project project) {
    return "${rootProject.name}${project.path}".replaceAll(':', '-')
}

final static boolean isLibraryOnClasspath(final Configuration classpath, final String groupName, final String artifactName) {
    return !classpath
            .filter { final File file -> isSubPath(file.toPath(), Paths.get(groupName, artifactName)) }
            .isEmpty()
}

final static boolean isSubPath(final java.nio.file.Path path1, final java.nio.file.Path path2) {
    final int path1NameCount = path1.getNameCount()
    final int path2NameCount = path2.getNameCount()
    if (path1NameCount == 0 || path2NameCount == 0) {
        return true
    } else {
        final java.nio.file.Path longerPath
        final int longerPathNameCount
        final java.nio.file.Path shorterPath
        final int shorterPathNameCount
        if (path1NameCount >= path2NameCount) {
            longerPath = path1
            longerPathNameCount = path1NameCount
            shorterPath = path2
            shorterPathNameCount = path2NameCount
        } else {
            longerPath = path2
            longerPathNameCount = path2NameCount
            shorterPath = path1
            shorterPathNameCount = path1NameCount
        }

        int shorterPathCurrentNameIndex = 0

        for (int longerPathNameIndex = 0; longerPathNameIndex < longerPathNameCount; ++longerPathNameIndex) {

            if (longerPath.getName(longerPathNameIndex) == shorterPath.getName(shorterPathCurrentNameIndex)) {
                ++shorterPathCurrentNameIndex
                if (shorterPathCurrentNameIndex == shorterPathNameCount) {
                    return true
                }
            } else {
                shorterPathCurrentNameIndex = 0
            }
        }
        return false
    }
}
